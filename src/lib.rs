// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

//! This library can help you generate libtool archive files to link
//! with existing C library.
//! 
//! Add this to Config.toml
//!
//! ```toml
//! [package]
//! build = "build.rs"
//! [build-dependencies]
//! libtool = "0.1"
//! ```
//!
//! And the build.rs file
//!
//! ```rust,no_run
//! extern crate libtool;
//!
//! fn main() {
//!     libtool::generate_convenience_lib("libfoo").unwrap();
//! }
//! ```
//!
//! It will automatically generate the file `target/{profile}/libfoo.la`

use std::env;
use std::fs::File;
use std::fs;
use std::io::prelude::*;
use std::os::unix::fs::symlink;
use std::path::PathBuf;

/// Generate libtool archive file ${lib}.la
pub fn generate_convenience_lib(lib: &str) -> std::io::Result<()> {
    let self_version = env!("CARGO_PKG_VERSION");
    let topdir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let profile = env::var("PROFILE").unwrap();
    let target_dir = format!("{}/target/{}", topdir, profile);
    let libs_dir = format!("{}/.libs", target_dir);
    let libs_path = PathBuf::from(&libs_dir);
    let la_path = PathBuf::from(format!("{}/{}.la", target_dir, lib));
    let old_lib_path = PathBuf::from(format!("{}/{}.a", target_dir, lib));
    let new_lib_path = PathBuf::from(format!("{}/{}.a", libs_dir, lib));
    fs::create_dir_all(&libs_path).unwrap();

    if la_path.exists() {
        fs::remove_file(&la_path)?;
    }
    if new_lib_path.exists() {
        fs::remove_file(&new_lib_path)?;
    }

    let mut file = File::create(&la_path)?;
    writeln!(file, "# {}.la - a libtool library file", lib)?;
    writeln!(file, "# Generated by libtool-rust {}", self_version)?;
    writeln!(file, "dlname=''")?;
    writeln!(file, "library_names=''")?;
    writeln!(file, "old_library='{}.a'", lib)?;
    writeln!(file, "inherited_linker_flags=' -pthread -lm -ldl'")?;
    writeln!(file, "installed=no")?;
    writeln!(file, "shouldnotlink=no")?;
    symlink(&old_lib_path, &new_lib_path)?;
    Ok(())
}
